/** @page PluginManagement Plugin management tutorial

<p>The Map2X::PluginManager::PluginManager class provides hierarchical plugin
management functions. Main features:</p>
<ul>
<li>Plugin manager version and plugin interface version checks to avoid
unexpected behavior</li>
<li>Both static and dynamic plugin support</li>
<li>Plugin dependecies and conflicts</li>
<li>Use checks, manager doesn't allow plugin unload if there are any active
plugin instances</li>
</ul>

@section PMInterface Plugin interface
<p>Plugin interface is class with well defined abstract public methods, which
defines the way how to work with a particular plugin.</p>
<p>Every plugin interface must be derived from PluginManager::Plugin class and
must reimplement Plugin constructor. This is needed for instance use checks, as
described above. Plugin classes derived from that interface must reimplement the
constructor too, of course.</p>
<p>Additionaly, interface must be defined with PLUGIN_INTERFACE() macro in
header to make sure loaded plugins will use the same interface in the same
version. One single argument is an string which uniquely names that particular
interface. A good practice is to use "Java package name"-style syntax because
this makes the name as unique as possible. The interface name should also
contain version identifier to make sure the plugin will not be loaded with
incompatible interface version.</p>
<p>So, there is an example interface class:</p>
@code
/* Filename: AbstractAnimal.h */
#ifndef AbstractAnimal_h
#define AbstractAnimal_h


#include "PluginManager/Plugin.h"

class AbstractAnimal: public Plugin {
    PLUGIN_INTERFACE("cz.mosra.Map2X.PluginManager.Test.AbstractAnimal/1.0")

    public:
        inline AbstractAnimal(AbstractPluginManager* manager = 0, const std::string& plugin = ""):
            Plugin(manager, plugin) {}

        virtual std::string name() = 0;
        virtual int legCount() = 0;
        virtual bool hasTail() = 0;
};

#endif
@endcode
@section PMPlugin Plugin definition
<p>Every plugin is represented by one class, which is derived from one plugin
interface. The plugin class in then registered as static or dynamic plugin.
Every plugin must also have its configuration file, which describes plugin
metadata such as plugin name, author, description etc. and optionally plugin
dependencies.</p>
<p>First we define one static plugin, which will be included in the
application out-of-the-box. After declaring that plugin we register it with
macro PLUGIN_REGISTER_STATIC(). The first argument is plugin name (which will be
used when instancing the plugin), second argument is name of the plugin class
and third is name of used plugin interface.</p>
@code
/* Filename: Canary.cpp */
#include "AbstractAnimal.h"

class Canary: public AbstractAnimal {
    public:
        inline Canary(AbstractPluginManager* manager = 0, const std::string& plugin = ""):
            AbstractAnimal(manager, plugin) {}

        std::string name() { return "Achoo"; }
        int legCount() { return 2; }
        bool hasTail() { return true; }
};

}}}

PLUGIN_REGISTER_STATIC(Canary, Canary,
                       "cz.mosra.Map2X.PluginManager.Test.AbstractAnimal/1.0")
@endcode
@code
# Filename: Canary.conf
[metadata]
name=I'm allergic to canaries!
@endcode
<p>Then we define one example dynamic plugin. Dynamic plugins are registered
with macro PLUGIN_REGISTER() which takes plugin class name as first argument and
interface name as second argument.</p>
@code
/* Filename: Dog.cpp */
#include "AbstractAnimal.h"

class Dog: public AbstractAnimal {
    public:
        inline Dog(AbstractPluginManager* manager = 0, const std::string& plugin = ""):
            AbstractAnimal(manager, plugin) {}

        std::string Dog::name() { return "Doug"; }
        bool Dog::hasTail() { return true; }
        int Dog::legCount() { return 4; }
};

PLUGIN_REGISTER(Dog,
                "cz.mosra.Map2X.PluginManager.Test.AbstractAnimal/1.0")
@endcode
@code
# Filename: Dog.conf
[metadata]
name=A simple dog plugin
@endcode
@section PMManagement Plugin management
<p>Now it's time to initialize Map2X::PluginManager::PluginManager class and
make use of the plugins. Map2X::PluginManager::PluginManager is template class
and that means it will load and make available only plugins which implement the
same interface as is specified as template of PluginManager instance, not any
other.</p>
<p>To make sure plugin manager will find the static plugins, we must import them
with a macro PLUGIN_IMPORT() (for example at the beginning of main function),
which takes plugin name as argument.</p>
<p>This example application will take first argument passed on commandline and
if a plugin is found and loaded successfully, displays brief info about a given
animal.</p>
@code
/* Filename: main.cpp */
#include <iostream>

#include "PluginManager/PluginManager.h"
#include "Canary.cpp"

using namespace std;
using namespace Map2X::PluginManager;

int main(int argc, char** argv) {
    /* Import static plugin using the same name as in Canary.cpp */
    PLUGIN_IMPORT_STATIC(CanaryPlugin);

    if(argc != 2) {
        cout << "Usage: " << argv[0] << " animal_plugin_name" << endl;
        return 1;
    }

    /* Initialize plugin manager with given directory */
    PluginManager<AbstractAnimal> manager(".");

    /* Try to load a plugin */
    if(!(manager.load(argv[1]) & (AbstractPluginManager::LoadOk|AbstractPluginManager::IsStatic))) {
        cerr << "The requested plugin cannot be loaded." << endl;
        return 2;
    }

    cout << "Using plugin '" << manager.metadata(argv[1])->name() << "'..."
         << endl << endl;

    /* Instance of an animal */
    AbstractAnimal* animal = manager.instance(argv[1]);

    cout << "Name:      " << animal->name() << endl
         << "Leg count: " << animal->legCount() << endl
         << "Has tail:  " << animal->hasTail() ? "yes" : "no" << endl;

    return 0;
}
@endcode
@section PMCompilation Plugin compilation
<p>@c Map2XMacros.cmake provides convenient CMake macros for compiling both
static and dynamic plugins:</p>
@code
# Filename: CMakeLists.txt
map2x_add_plugin(Dog ${CMAKE_CURRENT_BINARY_DIR} Dog.conf Dog.cpp)
map2x_add_static_plugin(StaticPlugins Canary Canary.conf Canary.cpp)

add_executable(PluginTest main.cpp)
target_link_libraries(PluginTest ${StaticPlugins})
@endcode
<p>@c map2x_add_plugin macro takes plugin name as first argument, second
argument is dir where to install the plugin files, third argument is name of
configuration file and after that comes one or more source files. We use the
build directory for storing the plugins to avoid the need for installation.</p>
<p>@c map2x_add_static_plugin macro compiles every static plugin as single
static library. To make linking easier for you, first argument is variable where
are stored names of all static plugins' libraries. The variable can be then
used for linking the final executable, as seen above.</p>
<p>After successfull compilation we can run the application with plugin name
as argument:</p>
<pre><strong>$</strong> ./PluginTest Dog
Using plugin 'A simple dog plugin'

Name:      Doug
Leg count: 4
Has tail:  yes
</pre>
 */
